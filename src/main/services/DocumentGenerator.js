/**
 * Document Generator Service
 * Handles Word document creation using docx library
 */

const { Document, Packer, Paragraph, TextRun, HeadingLevel, TableOfContents } = require('docx');
const fs = require('fs-extra');
const path = require('path');
const hljs = require('highlight.js');

class DocumentGenerator {
  constructor() {
    this.currentProgress = {
      currentFile: '',
      processedFiles: 0,
      totalFiles: 0,
      estimatedTimeRemaining: 0,
      errors: []
    };
  }

  /**
   * Generate Word document from files and configuration
   */
  async generateDocument(files, config) {
    try {
      this.resetProgress();

      // Filter and prepare files
      const processableFiles = this.filterProcessableFiles(files);
      this.currentProgress.totalFiles = processableFiles.length;

      let paragraphs = [];

      for (let i = 0; i < processableFiles.length; i++) {
        const file = processableFiles[i];
        this.currentProgress.currentFile = file.name;
        this.currentProgress.processedFiles = i;

        try {
          // Read file content
          const FileSystemService = require('./FileSystemService');
          const fsService = new FileSystemService();
          const fileContent = await fsService.readFileContent(file.path);

          if (!fileContent.binary && !fileContent.truncated) {
            // Split content into lines and create paragraphs
            fileContent.content.split('\n').forEach(line => {
              if (line.trim() === '') return;
              paragraphs.push(
                new Paragraph({
                  children: [
                    new TextRun({
                      text: line,
                      size: 17,
                    }),
                  ],
                  spacing: {
                    after: 59,
                  },
                })
              );
            });
          }
        } catch (error) {
          this.currentProgress.errors.push({
            file: file.path,
            error: error.message
          });
        }

        // Emit progress update
        this.emitProgress();
      }

      const doc = new Document({
        sections: [{
          properties: {
            page: {
              margin: {
                top: 1440,    // 2.54厘米
                right: 1440,
                bottom: 1440,
                left: 1440,
              },
            },
          },
          children: paragraphs,
        }],
      });

      // Generate output path
      const outputPath = this.generateOutputPath(config);

      // Save document
      const buffer = await Packer.toBuffer(doc);
      await fs.writeFile(outputPath, buffer);

      this.currentProgress.processedFiles = processableFiles.length;

      return {
        success: true,
        outputPath,
        statistics: {
          totalFiles: processableFiles.length,
          processedFiles: this.currentProgress.processedFiles,
          errors: this.currentProgress.errors.length,
          outputSize: buffer.length
        },
        errors: this.currentProgress.errors
      };
    } catch (error) {
      throw new Error(`Document generation failed: ${error.message}`);
    }
  }

  /**
   * Generate preview data without creating full document
   */
  async generatePreview(files, config) {
    const processableFiles = this.filterProcessableFiles(files);

    return {
      fileCount: processableFiles.length,
      estimatedPages: Math.ceil(processableFiles.length * 2.5), // Rough estimate
      structure: this.generateDocumentStructure(processableFiles),
      settings: config.documentSettings
    };
  }

  /**
   * Estimate document size
   */
  async estimateSize(files) {
    const processableFiles = this.filterProcessableFiles(files);
    let totalSize = 0;
    let totalLines = 0;

    for (const file of processableFiles) {
      if (file.type === 'file' && !file.excluded) {
        totalSize += file.size || 0;
        // Rough estimate of lines based on average line length
        totalLines += Math.ceil((file.size || 0) / 50);
      }
    }

    return {
      fileCount: processableFiles.length,
      totalSize,
      totalLines,
      estimatedPages: Math.ceil(totalLines / 50), // ~50 lines per page
      estimatedDocumentSize: totalSize * 1.5 // Word doc is usually larger
    };
  }  /**
   
* Create base document with settings
   */
  createDocument(config) {
    const { documentSettings } = config;

    return new Document({
      creator: documentSettings.author,
      title: documentSettings.title,
      description: 'Generated by Code2Word Converter',
      styles: {
        paragraphStyles: [
          {
            id: 'code',
            name: 'Code',
            basedOn: 'Normal',
            run: {
              font: documentSettings.formatting.codeFont,
              size: documentSettings.formatting.codeFontSize * 2 // docx uses half-points
            },
            paragraph: {
              spacing: { before: 100, after: 100 }
            }
          }
        ]
      },
      sections: []
    });
  }

  /**
   * Add table of contents to document
   */
  addTableOfContents(doc, config) {
    // Note: docx library has limited TOC support
    // This is a placeholder for future implementation
    doc.addSection({
      children: [
        new Paragraph({
          text: 'Table of Contents',
          heading: HeadingLevel.HEADING_1
        }),
        new Paragraph({
          text: '(Table of contents will be generated when document is opened in Word)',
          style: 'code'
        })
      ]
    });
  }

  /**
   * Add file section to document
   */
  async addFileSection(doc, file, config) {
    const { documentSettings } = config;

    // Add file header
    const fileHeader = new Paragraph({
      text: `File: ${file.relativePath}`,
      heading: HeadingLevel.HEADING_2
    });

    // Add file info
    const fileInfo = new Paragraph({
      children: [
        new TextRun(`Size: ${this.formatFileSize(file.size)} | `),
        new TextRun(`Modified: ${new Date(file.modified).toLocaleString()}`)
      ]
    });

    const children = [fileHeader, fileInfo];

    // Add file content if it's a text file
    if (file.type === 'file' && !file.isBinary) {
      try {
        const FileSystemService = require('./FileSystemService');
        const fsService = new FileSystemService();
        const fileContent = await fsService.readFileContent(file.path);

        if (!fileContent.binary && !fileContent.truncated) {
          const contentParagraphs = this.formatCodeContent(
            fileContent.content,
            file.extension,
            documentSettings.formatting
          );
          children.push(...contentParagraphs);
        } else {
          children.push(new Paragraph({
            text: fileContent.binary ? '[Binary file]' : '[File too large]',
            style: 'code'
          }));
        }
      } catch (error) {
        children.push(new Paragraph({
          text: `[Error reading file: ${error.message}]`,
          style: 'code'
        }));
      }
    }

    if (documentSettings.formatting.pageBreakBetweenFiles) {
      children.push(new Paragraph({
        text: '',
        pageBreakBefore: true
      }));
    } else {
      children.push(new Paragraph({
        text: '',
        spacing: { after: 400 }
      }));
    }

    if (doc.sections && doc.sections.length > 0) {
      doc.sections[0].children.push(...children);
    } else {
      // Create first section
      doc.addSection({
        children: children
      });
    }
  }  /*
*
   * Format code content with syntax highlighting
   */
  formatCodeContent(content, extension, formatting) {
    const paragraphs = [];
    const lines = content.split('\n');

    // Detect language for syntax highlighting
    const language = this.detectLanguage(extension);

    if (formatting.syntaxHighlighting && language && hljs.getLanguage(language)) {
      try {
        const highlighted = hljs.highlight(content, { language });
        // For now, just add as plain text since docx has limited formatting
        // Future enhancement: parse highlighted tokens and apply formatting
        lines.forEach((line, index) => {
          const lineNumber = formatting.lineNumbers ? `${index + 1}: ` : '';
          paragraphs.push(new Paragraph({
            text: lineNumber + line,
            style: 'code'
          }));
        });
      } catch (error) {
        // Fallback to plain text
        this.addPlainTextLines(lines, paragraphs, formatting);
      }
    } else {
      this.addPlainTextLines(lines, paragraphs, formatting);
    }

    return paragraphs;
  }

  /**
   * Add plain text lines to paragraphs
   */
  addPlainTextLines(lines, paragraphs, formatting) {
    lines.forEach((line, index) => {
      const lineNumber = formatting.lineNumbers ? `${index + 1}: ` : '';
      paragraphs.push(new Paragraph({
        text: lineNumber + line,
        style: 'code'
      }));
    });
  }

  /**
   * Detect programming language from file extension
   */
  detectLanguage(extension) {
    const languageMap = {
      '.js': 'javascript',
      '.ts': 'typescript',
      '.jsx': 'javascript',
      '.tsx': 'typescript',
      '.py': 'python',
      '.java': 'java',
      '.c': 'c',
      '.cpp': 'cpp',
      '.h': 'c',
      '.hpp': 'cpp',
      '.cs': 'csharp',
      '.php': 'php',
      '.rb': 'ruby',
      '.go': 'go',
      '.rs': 'rust',
      '.swift': 'swift',
      '.kt': 'kotlin',
      '.scala': 'scala',
      '.html': 'html',
      '.css': 'css',
      '.scss': 'scss',
      '.json': 'json',
      '.xml': 'xml',
      '.yaml': 'yaml',
      '.yml': 'yaml',
      '.sql': 'sql',
      '.sh': 'bash',
      '.bash': 'bash',
      '.ps1': 'powershell'
    };

    return languageMap[extension?.toLowerCase()] || null;
  }

  /**
   * Filter files that can be processed
   */
  filterProcessableFiles(files) {
    const processable = [];

    const traverse = (nodes) => {
      for (const node of nodes) {
        if (node.type === 'file' && !node.excluded) {
          processable.push(node);
        } else if (node.type === 'directory' && node.children) {
          traverse(node.children);
        }
      }
    };

    traverse(files);
    return processable;
  }  /**
   *
 Generate document structure for preview
   */
  generateDocumentStructure(files) {
    return files.map(file => ({
      name: file.name,
      path: file.relativePath,
      size: file.size,
      type: file.extension
    }));
  }

  /**
   * Generate output file path
   */
  generateOutputPath(config) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
    const projectName = path.basename(config.projectPath) || 'project';
    const fileName = `${projectName}_${timestamp}.docx`;

    return path.join(config.outputPath, fileName);
  }

  /**
   * Format file size for display
   */
  formatFileSize(bytes) {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  }

  /**
   * Reset progress tracking
   */
  resetProgress() {
    this.currentProgress = {
      currentFile: '',
      processedFiles: 0,
      totalFiles: 0,
      estimatedTimeRemaining: 0,
      errors: []
    };
  }

  /**
   * Emit progress update (placeholder for IPC communication)
   */
  emitProgress() {
    // This would emit progress to the renderer process
    // Implementation depends on how the main process communicates with renderer
    console.log(`Progress: ${this.currentProgress.processedFiles}/${this.currentProgress.totalFiles} - ${this.currentProgress.currentFile}`);
  }

  /**
   * Get current progress
   */
  getProgress() {
    return { ...this.currentProgress };
  }

  createDocumentWithContent(config, children) {
    const { documentSettings } = config;

    return new Document({
      creator: documentSettings.author,
      title: documentSettings.title,
      description: 'Generated by Code2Word Converter',
      styles: {
        paragraphStyles: [
          {
            id: 'code',
            name: 'Code',
            basedOn: 'Normal',
            run: {
              font: documentSettings.formatting.codeFont,
              size: documentSettings.formatting.codeFontSize * 2 // docx uses half-points
            },
            paragraph: {
              spacing: { before: 100, after: 100 }
            }
          }
        ]
      },
      sections: [
        {
          children: children
        }
      ]
    });
  }

  async generateFileContent(file, config, isLastFile = false) {
    const { documentSettings } = config;
    const children = [];

    children.push(new Paragraph({
      text: `File: ${file.relativePath}`,
      heading: HeadingLevel.HEADING_2
    }));

    children.push(new Paragraph({
      children: [
        new TextRun(`Size: ${this.formatFileSize(file.size)} | `),
        new TextRun(`Modified: ${new Date(file.modified).toLocaleString()}`)
      ]
    }));

    if (file.type === 'file' && !file.isBinary) {
      try {
        const FileSystemService = require('./FileSystemService');
        const fsService = new FileSystemService();
        const fileContent = await fsService.readFileContent(file.path);

        if (!fileContent.binary && !fileContent.truncated) {
          const contentParagraphs = this.formatCodeContent(
            fileContent.content,
            file.extension,
            documentSettings.formatting
          );
          children.push(...contentParagraphs);
        } else {
          children.push(new Paragraph({
            text: fileContent.binary ? '[Binary file]' : '[File too large]',
            style: 'code'
          }));
        }
      } catch (error) {
        children.push(new Paragraph({
          text: `[Error reading file: ${error.message}]`,
          style: 'code'
        }));
      }
    }

    if (!isLastFile) {
      if (documentSettings.formatting.pageBreakBetweenFiles) {
        children.push(new Paragraph({
          text: '',
          pageBreakBefore: true
        }));
      } else {
        children.push(
          new Paragraph({ text: '' }),
          new Paragraph({ text: '─'.repeat(50) }),
          new Paragraph({ text: '' })
        );
      }
    }

    return children;
  }
}

module.exports = DocumentGenerator;